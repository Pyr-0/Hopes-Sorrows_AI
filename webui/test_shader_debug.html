<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shader Debug Test</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: white;
            font-family: monospace;
        }
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #debug {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            max-width: 400px;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="debug">
        <h3>Shader Debug Info</h3>
        <div id="webgl-info"></div>
        <div id="shader-status"></div>
        <div id="error-log"></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const debugDiv = document.getElementById('debug');
        const webglInfo = document.getElementById('webgl-info');
        const shaderStatus = document.getElementById('shader-status');
        const errorLog = document.getElementById('error-log');

        function log(message) {
            console.log(message);
            errorLog.innerHTML += message + '<br>';
        }

        function testShader() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) {
                log('❌ WebGL not supported');
                return;
            }

            // Display WebGL info
            webglInfo.innerHTML = `
                <strong>WebGL Info:</strong><br>
                Vendor: ${gl.getParameter(gl.VENDOR)}<br>
                Renderer: ${gl.getParameter(gl.RENDERER)}<br>
                Version: ${gl.getParameter(gl.VERSION)}<br>
                GLSL Version: ${gl.getParameter(gl.SHADING_LANGUAGE_VERSION)}<br>
            `;

            log('✅ WebGL context created');

            // Simple vertex shader
            const vertexSource = `
                attribute vec2 a_position;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;

            // Test fragment shader - start simple
            const fragmentSource = `
                precision mediump float;
                uniform vec2 u_resolution;
                uniform float u_time;
                
                void main() {
                    vec2 uv = gl_FragCoord.xy / u_resolution;
                    vec3 color = vec3(uv.x, uv.y, sin(u_time));
                    gl_FragColor = vec4(color, 1.0);
                }
            `;

            function createShader(type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    const error = gl.getShaderInfoLog(shader);
                    log(`❌ ${type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment'} shader error: ${error}`);
                    gl.deleteShader(shader);
                    return null;
                }

                log(`✅ ${type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment'} shader compiled`);
                return shader;
            }

            const vertexShader = createShader(gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSource);

            if (!vertexShader || !fragmentShader) {
                log('❌ Shader compilation failed');
                return;
            }

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                const error = gl.getProgramInfoLog(program);
                log(`❌ Program link error: ${error}`);
                return;
            }

            log('✅ Program linked successfully');

            // Get uniform locations
            const uniforms = {
                resolution: gl.getUniformLocation(program, 'u_resolution'),
                time: gl.getUniformLocation(program, 'u_time')
            };

            // Create vertex buffer
            const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.viewport(0, 0, canvas.width, canvas.height);

            log('✅ Basic shader test successful');
            shaderStatus.innerHTML = '<strong style="color: green;">✅ Basic shader working</strong>';

            // Animation loop
            function animate() {
                const time = Date.now() * 0.001;

                gl.useProgram(program);
                gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
                gl.uniform1f(uniforms.time, time);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                requestAnimationFrame(animate);
            }

            animate();
        }

        // Test on load
        testShader();
    </script>
</body>
</html> 